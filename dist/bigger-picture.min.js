var app = (function () {

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;

	const TRANSITION_IN = 1;
	const TRANSITION_OUT = 1 << 1;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	const DEV = false;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Detected a migrated `$:` reactive block in `%filename%` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an `$effect`.
	 * @param {string} filename
	 */
	function legacy_recursive_reactive_block(filename) {
		{
			// TODO print a link to the documentation
			console.warn("legacy_recursive_reactive_block");
		}
	}

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run$1(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const UNOWNED = 1 << 7;
	const DISCONNECTED = 1 << 8;
	const CLEAN = 1 << 9;
	const DIRTY = 1 << 10;
	const MAYBE_DIRTY = 1 << 11;
	const INERT = 1 << 12;
	const DESTROYED = 1 << 13;
	const EFFECT_RAN = 1 << 14;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 15;
	/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */
	const LEGACY_DERIVED_PROP = 1 << 16;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_HAS_DERIVED = 1 << 19;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/** @import { Equals } from '#client' */
	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function not_equal(a, b) {
		return a !== b;
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			// TODO print a link to the documentation
			throw new Error("effect_in_teardown");
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			// TODO print a link to the documentation
			throw new Error("effect_in_unowned_derived");
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			// TODO print a link to the documentation
			throw new Error("effect_orphan");
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			// TODO print a link to the documentation
			throw new Error("effect_update_depth_exceeded");
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			// TODO print a link to the documentation
			throw new Error("props_invalid_value");
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			// TODO print a link to the documentation
			throw new Error("state_descriptors_fixed");
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			// TODO print a link to the documentation
			throw new Error("state_prototype_fixed");
		}
	}

	/**
	 * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state
	 * @returns {never}
	 */
	function state_unsafe_local_read() {
		{
			// TODO print a link to the documentation
			throw new Error("state_unsafe_local_read");
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			// TODO print a link to the documentation
			throw new Error("state_unsafe_mutation");
		}
	}

	let legacy_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	/**
	 * @template V
	 * @param {V} v
	 * @returns {Source<V>}
	 */
	function source(v) {
		return {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			version: 0
		};
	}

	/**
	 * @template V
	 * @param {V} v
	 */
	function state(v) {
		return push_derived_source(source(v));
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	function mutable_state(v, immutable = false) {
		return push_derived_source(mutable_source(v, immutable));
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function push_derived_source(source) {
		if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
			if (derived_sources === null) {
				set_derived_sources([source]);
			} else {
				derived_sources.push(source);
			}
		}

		return source;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function set(source, value) {
		if (
			active_reaction !== null &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			// If the source was created locally within the current derived, then
			// we allow the mutation.
			(derived_sources === null || !derived_sources.includes(source))
		) {
			state_unsafe_mutation();
		}

		return internal_set(source, value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			source.v = value;
			source.version = increment_version();

			mark_reactions(source, DIRTY);

			// If the current signal is running for the first time, it won't have any
			// reactions as we only allocate and assign the reactions after the signal
			// has fully executed. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & BRANCH_EFFECT) === 0
			) {
				if (new_deps !== null && new_deps.includes(source)) {
					set_signal_status(active_effect, DIRTY);
					schedule_effect(active_effect);
				} else {
					if (untracked_writes === null) {
						set_untracked_writes([source]);
					} else {
						untracked_writes.push(source);
					}
				}
			}
		}

		return value;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;

		if (active_effect === null) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			children: null,
			ctx: component_context,
			deps: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			v: /** @type {V} */ (null),
			version: 0,
			parent: active_effect
		};

		if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
			var derived = /** @type {Derived} */ (active_reaction);
			(derived.children ??= []).push(signal);
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_children(derived) {
		var children = derived.children;

		if (children !== null) {
			derived.children = null;

			for (var i = 0; i < children.length; i += 1) {
				var child = children[i];
				if ((child.f & DERIVED) !== 0) {
					destroy_derived(/** @type {Derived} */ (child));
				} else {
					destroy_effect(/** @type {Effect} */ (child));
				}
			}
		}
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(derived.parent);

		{
			try {
				destroy_derived_children(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.version = increment_version();
		}
	}

	/**
	 * @param {Derived} signal
	 * @returns {void}
	 */
	function destroy_derived(signal) {
		destroy_derived_children(signal);
		remove_reactions(signal, 0);
		set_signal_status(signal, DESTROYED);

		// TODO we need to ensure we remove the derived from any parent derives
		signal.v = signal.children = signal.deps = signal.ctx = signal.reactions = null;
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, Reaction, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan();
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var is_root = (type & ROOT_EFFECT) !== 0;
		var parent_effect = active_effect;

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			deriveds: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent: is_root ? null : parent_effect,
			prev: null,
			teardown: null,
			transitions: null,
			version: 0
		};

		if (sync) {
			var previously_flushing_effect = is_flushing_effect;

			try {
				set_is_flushing_effect(true);
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			} finally {
				set_is_flushing_effect(previously_flushing_effect);
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & EFFECT_HAS_DERIVED) === 0;

		if (!inert && !is_root && push) {
			if (parent_effect !== null) {
				push_effect(effect, parent_effect);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.children ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect();

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect();
		return render_effect(fn);
	}

	/**
	 * Internal representation of `$effect.root(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {() => void}
	 */
	function effect_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);
		return () => {
			destroy_effect(effect);
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean }} */
		var token = { effect: null, ran: false };
		context.l.r1.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			set(context.l.r2, true);
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			if (!get(context.l.r2)) return;

			// Run dirty `$:` statements
			for (var token of context.l.r1) {
				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (check_dirtiness(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}

			context.l.r2.v = false; // set directly to avoid rerunning this effect
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function template_effect(fn) {
		return block(fn);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_effect_deriveds(signal) {
		var deriveds = signal.deriveds;

		if (deriveds !== null) {
			signal.deriveds = null;

			for (var i = 0; i < deriveds.length; i += 1) {
				destroy_derived(deriveds[i]);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;
			destroy_effect(effect, remove_dom);
			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			/** @type {TemplateNode | null} */
			var node = effect.nodes_start;
			var end = effect.nodes_end;

			while (node !== null) {
				/** @type {TemplateNode | null} */
				var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

				node.remove();
				node = next;
			}

			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		destroy_effect_deriveds(effect);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		// `first` and `child` are nulled out in destroy_effect_children
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.parent =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;

		// If a dependency of this effect changed while it was paused,
		// apply the change now
		if (check_dirtiness(effect)) {
			update_effect(effect);
		}

		// Ensure we toggle the flag after possibly updating the effect so that
		// each block logic can correctly operate on inert items
		effect.f ^= INERT;

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	let is_micro_task_queued$1 = false;

	/** @type {Array<() => void>} */
	let current_queued_micro_tasks = [];

	function process_micro_tasks() {
		is_micro_task_queued$1 = false;
		const tasks = current_queued_micro_tasks.slice();
		current_queued_micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (!is_micro_task_queued$1) {
			is_micro_task_queued$1 = true;
			queueMicrotask(process_micro_tasks);
		}
		current_queued_micro_tasks.push(fn);
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */
	// Used for handling scheduling
	let is_micro_task_queued = false;

	let is_flushing_effect = false;
	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_flushing_effect(value) {
		is_flushing_effect = value;
	}

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	let flush_count = 0;
	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a derived, we record them so that we can safely allow
	 * local mutations to these sources without the side-effect error being invoked unnecessarily.
	 * @type {null | Source[]}
	 */
	let derived_sources = null;

	/**
	 * @param {Source[] | null} sources
	 */
	function set_derived_sources(sources) {
		derived_sources = sources;
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */
	let current_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	// Handling runtime component context
	/** @type {ComponentContext | null} */
	let component_context = null;

	function increment_version() {
		return ++current_version;
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;

				if ((flags & DISCONNECTED) !== 0) {
					for (i = 0; i < dependencies.length; i++) {
						(dependencies[i].reactions ??= []).push(reaction);
					}

					reaction.f ^= DISCONNECTED;
				}

				for (i = 0; i < dependencies.length; i++) {
					var dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					// If we are working with an unowned signal as part of an effect (due to !skip_reaction)
					// and the version hasn't changed, we still need to check that this reaction
					// is linked to the dependency source – otherwise future updates will not be caught.
					if (
						is_unowned &&
						active_effect !== null &&
						!skip_reaction &&
						!dependency?.reactions?.includes(reaction)
					) {
						(dependency.reactions ??= []).push(reaction);
					}

					if (dependency.version > reaction.version) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean.
			if (!is_unowned) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Error} error
	 * @param {Effect} effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, component_context) {
		// Given we don't yet have error boundaries, we will just always throw.
		{
			throw error;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var prev_derived_sources = derived_sources;
		var previous_component_context = component_context;
		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
		skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
		derived_sources = null;
		component_context = reaction.ctx;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			derived_sources = prev_derived_sources;
			component_context = previous_component_context;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = reactions.indexOf(signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;

		active_effect = effect;

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}
			destroy_effect_deriveds(effect);

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.version = current_version;

			if (DEV) ;
		} catch (error) {
			handle_error(/** @type {Error} */ (error));
		} finally {
			active_effect = previous_effect;
		}
	}

	function infinite_loop_guard() {
		if (flush_count > 1000) {
			flush_count = 0;
			{
				effect_update_depth_exceeded();
			}
		}
		flush_count++;
	}

	/**
	 * @param {Array<Effect>} root_effects
	 * @returns {void}
	 */
	function flush_queued_root_effects(root_effects) {
		var length = root_effects.length;
		if (length === 0) {
			return;
		}
		infinite_loop_guard();

		var previously_flushing_effect = is_flushing_effect;
		is_flushing_effect = true;

		try {
			for (var i = 0; i < length; i++) {
				var effect = root_effects[i];

				if ((effect.f & CLEAN) === 0) {
					effect.f ^= CLEAN;
				}

				/** @type {Effect[]} */
				var collected_effects = [];

				process_effects(effect, collected_effects);
				flush_queued_effects(collected_effects);
			}
		} finally {
			is_flushing_effect = previously_flushing_effect;
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {
				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					if (effect.teardown === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}
			}
		}
	}

	function process_deferred() {
		is_micro_task_queued = false;
		if (flush_count > 1001) {
			return;
		}
		const previous_queued_root_effects = queued_root_effects;
		queued_root_effects = [];
		flush_queued_root_effects(previous_queued_root_effects);
		if (!is_micro_task_queued) {
			flush_count = 0;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		{
			if (!is_micro_task_queued) {
				is_micro_task_queued = true;
				queueMicrotask(process_deferred);
			}
		}

		var effect = signal;

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} effect
	 * @param {Effect[]} collected_effects
	 * @returns {void}
	 */
	function process_effects(effect, collected_effects) {
		var current_effect = effect.first;
		var effects = [];

		main_loop: while (current_effect !== null) {
			var flags = current_effect.f;
			var is_branch = (flags & BRANCH_EFFECT) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & RENDER_EFFECT) !== 0) {
					if (is_branch) {
						current_effect.f ^= CLEAN;
					} else if (check_dirtiness(current_effect)) {
						update_effect(current_effect);
					}

					var child = current_effect.first;

					if (child !== null) {
						current_effect = child;
						continue;
					}
				} else if ((flags & EFFECT) !== 0) {
					effects.push(current_effect);
				}
			}

			var sibling = current_effect.next;

			if (sibling === null) {
				let parent = current_effect.parent;

				while (parent !== null) {
					if (effect === parent) {
						break main_loop;
					}
					var parent_sibling = parent.next;
					if (parent_sibling !== null) {
						current_effect = parent_sibling;
						continue main_loop;
					}
					parent = parent.parent;
				}
			}

			current_effect = sibling;
		}

		// We might be dealing with many effects here, far more than can be spread into
		// an array push call (callstack overflow). So let's deal with each effect in a loop.
		for (var i = 0; i < effects.length; i++) {
			child = effects[i];
			collected_effects.push(child);
			process_effects(child, collected_effects);
		}
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// If the derived is destroyed, just execute it again without retaining
		// its memoisation properties as the derived is stale
		if (is_derived && (flags & DESTROYED) !== 0) {
			var value = execute_derived(/** @type {Derived} */ (signal));
			// Ensure the derived remains destroyed
			destroy_derived(/** @type {Derived} */ (signal));
			return value;
		}

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null) {
			if (derived_sources !== null && derived_sources.includes(signal)) {
				state_unsafe_local_read();
			}
			var deps = active_reaction.deps;

			// If the signal is accessing the same dependencies in the same
			// order as it did last time, increment `skipped_deps`
			// rather than updating `new_deps`, which creates GC cost
			if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
				skipped_deps++;
			} else if (new_deps === null) {
				new_deps = [signal];
			} else {
				new_deps.push(signal);
			}

			if (
				untracked_writes !== null &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & BRANCH_EFFECT) === 0 &&
				untracked_writes.includes(signal)
			) {
				set_signal_status(active_effect, DIRTY);
				schedule_effect(active_effect);
			}
		} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && !parent.deriveds?.includes(derived)) {
				(parent.deriveds ??= []).push(derived);
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		const previous_reaction = active_reaction;
		try {
			active_reaction = null;
			return fn();
		} finally {
			active_reaction = previous_reaction;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		};

		if (legacy_mode_flag && !runes) {
			component_context.l = {
				s: null,
				u: null,
				r1: [],
				r2: source(false)
			};
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @param {ProxyMetadata | null} [parent]
	 * @param {Source<T>} [prev] dev mode only
	 * @returns {T}
	 */
	function proxy(value, parent = null, prev) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = source(0);

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', source(/** @type {any[]} */ (value).length));
		}

		/** @type {ProxyMetadata} */
		var metadata;

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = source(descriptor.value);
					sources.set(prop, s);
				} else {
					set(s, proxy(descriptor.value, metadata));
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(prop, source(UNINITIALIZED));
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {

				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);

					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {

				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);
						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = source(UNINITIALIZED);
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = source(undefined);
						set(s, proxy(value, metadata));
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set(s, proxy(value, metadata));
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		// the following assignments improve perf of lookups on DOM nodes
		// @ts-expect-error
		element_prototype.__click = undefined;
		// @ts-expect-error
		element_prototype.__className = '';
		// @ts-expect-error
		element_prototype.__attributes = null;
		// @ts-expect-error
		element_prototype.__styles = null;
		// @ts-expect-error
		element_prototype.__e = undefined;

		// @ts-expect-error
		Text.prototype.__t = undefined;
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		{
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @import { Location } from 'locate-character' */

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} handler
	 * @param {AddEventListenerOptions} options
	 */
	function create_event(event_name, dom, handler, options) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} handler
	 * @param {boolean} capture
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		// @ts-ignore
		if (dom === document.body || dom === window || dom === document) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	function comment() {

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true — block effects should run their intro transitions —
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = effect_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}

				should_intro = intro;
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};
				should_intro = true;

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);
				mounted_components.delete(component);
				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {() => boolean} get_condition
	 * @param {(anchor: Node) => void} consequent_fn
	 * @param {null | ((anchor: Node) => void)} [alternate_fn]
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {boolean | null} */
		var condition = null;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		block(() => {
			if (condition === (condition = !!get_condition())) return;

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else {
					consequent_effect = branch(() => consequent_fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (alternate_fn) {
					alternate_effect = branch(() => alternate_fn(anchor));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}
		}, flags);
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @template V
	 * @param {TemplateNode} node
	 * @param {() => V} get_key
	 * @param {(anchor: Node) => TemplateNode | void} render_fn
	 * @returns {void}
	 */
	function key_block(node, get_key, render_fn) {

		var anchor = node;

		/** @type {V | typeof UNINITIALIZED} */
		var key = UNINITIALIZED;

		/** @type {Effect} */
		var effect;

		var changed = is_runes() ? not_equal : safe_not_equal;

		block(() => {
			if (changed(key, (key = get_key()))) {
				if (effect) {
					pause_effect(effect);
				}

				effect = branch(() => render_fn(anchor));
			}
		});
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} svg
	 * @param {boolean} mathml
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg, mathml, skip_warning) {
		var anchor = node;

		var value = '';

		/** @type {Effect | undefined} */
		var effect;

		block(() => {
			if (value === (value = get_value() ?? '')) {
				return;
			}

			if (effect !== undefined) {
				destroy_effect(effect);
				effect = undefined;
			}

			if (value === '') return;

			effect = branch(() => {

				var html = value + '';

				// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
				// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
				/** @type {DocumentFragment | Element} */
				var node = create_fragment_from_html(html);

				assign_nodes(
					/** @type {TemplateNode} */ (get_first_child(node)),
					/** @type {TemplateNode} */ (node.lastChild)
				);

				{
					anchor.before(node);
				}
			});
		});
	}

	/** @import { ActionPayload } from '#client' */

	/**
	 * @template P
	 * @param {Element} dom
	 * @param {(dom: Element, value?: P) => ActionPayload<P>} action
	 * @param {() => P} [get_value]
	 * @returns {void}
	 */
	function action(dom, action, get_value) {
		effect(() => {
			var payload = untrack(() => action(dom, get_value?.()) || {});

			if (payload?.destroy) {
				return () => /** @type {Function} */ (payload.destroy)();
			}
		});
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'style' && '__styles' in element) {
			// reset styles to force style: directive to update
			element.__styles = {};
		}

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));
		var descriptors;
		var proto = get_prototype_of(element);
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {Element} dom
	 * @param {string} class_name
	 * @param {boolean} value
	 * @returns {void}
	 */
	function toggle_class(dom, class_name, value) {
		if (value) {
			if (dom.classList.contains(class_name)) return;
			dom.classList.add(class_name);
		} else {
			if (!dom.classList.contains(class_name)) return;
			dom.classList.remove(class_name);
		}
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {string} key
	 * @param {string} value
	 * @param {boolean} [important]
	 */
	function set_style(dom, key, value, important) {
		// @ts-expect-error
		var styles = (dom.__styles ??= {});

		if (styles[key] === value) {
			return;
		}

		styles[key] = value;

		if (value == null) {
			dom.style.removeProperty(key);
		} else {
			dom.style.setProperty(key, value, '');
		}
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		element.dispatchEvent(new CustomEvent(type));
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear$1 = (t) => t;

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_intro = (flags & TRANSITION_IN) !== 0;
		var is_outro = (flags & TRANSITION_OUT) !== 0;
		var is_both = is_intro && is_outro;
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = is_both ? 'both' : is_intro ? 'in' : 'out';

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			var previous_reaction = active_reaction;
			var previous_effect = active_effect;
			set_active_reaction(null);
			set_active_effect(null);
			try {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			} finally {
				set_active_reaction(previous_reaction);
				set_active_effect(previous_effect);
			}
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				if (!is_intro) {
					outro?.abort();
					outro?.reset?.();
					return;
				}

				if (!is_outro) {
					// if we intro then outro then intro again, we want to abort the first intro,
					// if it's not a bidirectional transition
					intro?.abort();
				}

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;
				});
			},
			out(fn) {
				if (!is_outro) {
					fn?.();
					current_options = undefined;
					return;
				}

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (is_intro && should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value — `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear$1 } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		var animation = element.animate(keyframes, { duration: delay });

		animation.onfinish = () => {
			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css(t, 1 - t);
						keyframes.push(css_to_keyframe(styles));
					}
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run$1));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get(signal);
		}

		props();
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		if (entry.store !== store) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		return get(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {StoreReferencesContainer}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		teardown(() => {
			for (var store_name in stores) {
				const ref = stores[store_name];
				ref.unsubscribe();
			}
		});

		return stores;
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Source } from './types.js' */

	/**
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function with_parent_branch(fn) {
		var effect = active_effect;
		var previous_effect = active_effect;

		while (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
			effect = effect.parent;
		}
		try {
			set_active_effect(effect);
			return fn();
		} finally {
			set_active_effect(previous_effect);
		}
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
		var is_store_sub = false;
		var prop_value;

		if (bindable) {
			[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			prop_value = /** @type {V} */ (props[key]);
		}

		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

		var setter =
			get_descriptor(props, key)?.set ??
			(is_entry_props && bindable && key in props ? (v) => (props[key] = v) : undefined);

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;
		var fallback_used = false;

		var get_fallback = () => {
			fallback_used = true;
			if (fallback_dirty) {
				fallback_dirty = false;
				if (lazy) {
					fallback_value = untrack(/** @type {() => V} */ (fallback));
				} else {
					fallback_value = /** @type {V} */ (fallback);
				}
			}

			return fallback_value;
		};

		if (prop_value === undefined && fallback !== undefined) {
			if (setter && runes) {
				props_invalid_value();
			}

			prop_value = get_fallback();
			if (setter) setter(prop_value);
		}

		/** @type {() => V} */
		var getter;
		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				fallback_used = false;
				return value;
			};
		} else {
			// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
			// Replicate that behavior through using a derived
			var derived_getter = with_parent_branch(() =>
				(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))
			);
			derived_getter.f |= LEGACY_DERIVED_PROP;
			getter = () => {
				var value = get(derived_getter);
				if (value !== undefined) fallback_value = /** @type {V} */ (undefined);
				return value === undefined ? fallback_value : value;
			};
		}

		// easy mode — prop is never written to
		if ((flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// intermediate mode — prop is written to, but the parent component had
		// `bind:foo` which means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					// We don't want to notify if the value was mutated and the parent is in runes mode.
					// In that case the state proxy (if it exists) should take care of the notification.
					// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
					// has changed because the parent will not be able to detect the change otherwise.
					if (!runes || !mutation || legacy_parent || is_store_sub) {
						/** @type {Function} */ (setter)(mutation ? getter() : value);
					}
					return value;
				} else {
					return getter();
				}
			};
		}

		// hard mode. this is where it gets ugly — the value in the child should
		// synchronize with the parent, but it should also be possible to temporarily
		// set the value to something else locally.
		var from_child = false;
		var was_from_child = false;

		// The derived returns the current value. The underlying mutable
		// source is written to from various places to persist this value.
		var inner_current_value = mutable_source(prop_value);
		var current_value = with_parent_branch(() =>
			derived(() => {
				var parent_value = getter();
				var child_value = get(inner_current_value);

				if (from_child) {
					from_child = false;
					was_from_child = true;
					return child_value;
				}

				was_from_child = false;
				return (inner_current_value.v = parent_value);
			})
		);

		if (!immutable) current_value.equals = safe_equals;

		return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {

			if (arguments.length > 0) {
				const new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;

				if (!current_value.equals(new_value)) {
					from_child = true;
					set(inner_current_value, new_value);
					// To ensure the fallback value is consistent when used with proxies, we
					// update the local fallback_value, but only if the fallback is actively used
					if (fallback_used && fallback_value !== undefined) {
						fallback_value = new_value;
					}
					untrack(() => get(current_value)); // force a synchronisation immediately
				}

				return value;
			}
			return get(current_value);
		};
	}

	/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */

	/**
	 * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
	 *
	 * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.
	 * @param {() => void | (() => void)} fn
	 * @returns {void}
	 */
	function run(fn) {
		user_pre_effect(() => {
			fn();
			var effect = /** @type {import('#client').Effect} */ (active_effect);
			// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour
			if ((effect.f & DIRTY) !== 0) {
				legacy_recursive_reactive_block();
				set_signal_status(effect, MAYBE_DIRTY);
			}
		});
	}

	/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */
	/** @param {number} x */

	/** @param {number} t */
	function cubic_out(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/** @param {number | string} value
	 * @returns {[number, string]}
	 */
	function split_css_unit(value) {
		const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
		return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];
	}

	/**
	 * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.
	 *
	 * @param {Element} node
	 * @param {FlyParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fly(
		node,
		{ delay = 0, duration = 400, easing = cubic_out, x = 0, y = 0, opacity = 0 } = {}
	) {
		const style = getComputedStyle(node);
		const target_opacity = +style.opacity;
		const transform = style.transform === 'none' ? '' : style.transform;
		const od = target_opacity * (1 - opacity);
		const [x_value, x_unit] = split_css_unit(x);
		const [y_value, y_unit] = split_css_unit(y);
		return {
			delay,
			duration,
			easing,
			css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x_value}${x_unit}, ${(1 - t) * y_value}${y_unit});
			opacity: ${target_opacity - od * u}`
		};
	}

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/

	/**
	 * @param {number} t
	 * @returns {number}
	 */
	function linear(t) {
		return t;
	}

	/**
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	enable_legacy_mode_flag();

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * @param {any} obj
	 * @returns {obj is Date}
	 */
	function is_date(obj) {
		return Object.prototype.toString.call(obj) === '[object Date]';
	}

	/** @import { Task } from '../internal/client/types' */
	/** @import { Tweened } from './public' */
	/** @import { TweenedOptions } from './private' */

	/**
	 * @template T
	 * @param {T} a
	 * @param {T} b
	 * @returns {(t: number) => T}
	 */
	function get_interpolator(a, b) {
		if (a === b || a !== a) return () => a;

		const type = typeof a;
		if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
			throw new Error('Cannot interpolate values of different type');
		}

		if (Array.isArray(a)) {
			const arr = /** @type {Array<any>} */ (b).map((bi, i) => {
				return get_interpolator(/** @type {Array<any>} */ (a)[i], bi);
			});

			// @ts-ignore
			return (t) => arr.map((fn) => fn(t));
		}

		if (type === 'object') {
			if (!a || !b) {
				throw new Error('Object cannot be null');
			}

			if (is_date(a) && is_date(b)) {
				const an = a.getTime();
				const bn = b.getTime();
				const delta = bn - an;

				// @ts-ignore
				return (t) => new Date(an + t * delta);
			}

			const keys = Object.keys(b);

			/** @type {Record<string, (t: number) => T>} */
			const interpolators = {};
			keys.forEach((key) => {
				// @ts-ignore
				interpolators[key] = get_interpolator(a[key], b[key]);
			});

			// @ts-ignore
			return (t) => {
				/** @type {Record<string, any>} */
				const result = {};
				keys.forEach((key) => {
					result[key] = interpolators[key](t);
				});
				return result;
			};
		}

		if (type === 'number') {
			const delta = /** @type {number} */ (b) - /** @type {number} */ (a);
			// @ts-ignore
			return (t) => a + t * delta;
		}

		throw new Error(`Cannot interpolate ${type} values`);
	}

	/**
	 * A tweened store in Svelte is a special type of store that provides smooth transitions between state values over time.
	 *
	 * @template T
	 * @param {T} [value]
	 * @param {TweenedOptions<T>} [defaults]
	 * @returns {Tweened<T>}
	 */
	function tweened(value, defaults = {}) {
		const store = writable(value);
		/** @type {Task} */
		let task;
		let target_value = value;
		/**
		 * @param {T} new_value
		 * @param {TweenedOptions<T>} [opts]
		 */
		function set(new_value, opts) {
			target_value = new_value;

			if (value == null) {
				store.set((value = new_value));
				return Promise.resolve();
			}

			/** @type {Task | null} */
			let previous_task = task;

			let started = false;
			let {
				delay = 0,
				duration = 400,
				easing = linear,
				interpolate = get_interpolator
			} = { ...defaults, ...opts };

			if (duration === 0) {
				if (previous_task) {
					previous_task.abort();
					previous_task = null;
				}
				store.set((value = target_value));
				return Promise.resolve();
			}

			const start = raf.now() + delay;

			/** @type {(t: number) => T} */
			let fn;
			task = loop((now) => {
				if (now < start) return true;
				if (!started) {
					fn = interpolate(/** @type {any} */ (value), new_value);
					if (typeof duration === 'function')
						duration = duration(/** @type {any} */ (value), new_value);
					started = true;
				}
				if (previous_task) {
					previous_task.abort();
					previous_task = null;
				}
				const elapsed = now - start;
				if (elapsed > /** @type {number} */ (duration)) {
					store.set((value = new_value));
					return false;
				}
				// @ts-ignore
				store.set((value = fn(easing(elapsed / duration))));
				return true;
			});
			return task.promise;
		}
		return {
			set,
			update: (fn, opts) =>
				set(fn(/** @type {any} */ (target_value), /** @type {any} */ (value)), opts),
			subscribe: store.subscribe
		};
	}

	/** true if gallery is in the process of closing */
	const closing = writable(0);

	/** if user prefers reduced motion  */
	const prefersReducedMotion = globalThis.matchMedia?.(
		'(prefers-reduced-motion: reduce)'
	).matches;

	/** default options for tweens / transitions
	 * @param {number} duration
	 */
	const defaultTweenOptions = (duration) => ({
		easing: cubicOut,
		duration: prefersReducedMotion ? 0 : duration,
	});

	const getThumbBackground = (activeItem) =>
		!activeItem.thumb || `url(${activeItem.thumb})`;

	/**
	 * Adds attributes to the given node based on the provided object.
	 *
	 * @param {HTMLElement} node - The node to which attributes will be added
	 * @param {Record<string, string | boolean> | string} obj - The object containing key-value pairs of attributes to be added
	 */
	const addAttributes = (node, obj) => {
		if (!obj) {
			return
		}
		if (typeof obj === 'string') {
			obj = JSON.parse(obj);
		}
		for (const key in obj) {
			node.setAttribute(key, obj[key]);
		}
	};

	var root_1$2 = template(`<div class="bp-load"><span class="bp-bar"></span> <span class="bp-o"></span></div>`);
	var root_2$1 = template(`<div class="bp-load"></div>`);
	var root$3 = template(`<!> <!>`, 1);

	function Loading($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $closing = () => store_get(closing, "$closing", $$stores);
		var fragment = root$3();
		var node = first_child(fragment);

		if_block(node, () => !$$props.loaded, ($$anchor) => {
			var div = root_1$2();
			const style_directive = derived(() => getThumbBackground($$props.activeItem));

			template_effect(() => set_style(div, "background-image", get(style_directive)));
			transition(2, div, () => fly, () => ({ duration: 480 }));
			append($$anchor, div);
		});

		var node_1 = sibling(node, 2);

		if_block(node_1, $closing, ($$anchor) => {
			var div_1 = root_2$1();
			const style_directive_1 = derived(() => getThumbBackground($$props.activeItem));

			template_effect(() => set_style(div_1, "background-image", get(style_directive_1)));
			transition(5, div_1, () => fly, () => ({ duration: 480 }));
			append($$anchor, div_1);
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$1 = template(`<img>`);
	var root$2 = template(`<div class="bp-img-wrap"><div class="bp-img"><!> <!></div></div>`);

	function Image($$anchor, $$props) {
		push($$props, false);

		const $$stores = setup_stores();
		const $imageDimensions = () => store_get(imageDimensions, "$imageDimensions", $$stores);
		const $closing = () => store_get(closing, "$closing", $$stores);
		const $zoomDragTranslate = () => store_get(zoomDragTranslate, "$zoomDragTranslate", $$stores);
		const $zoomed = () => store_get(zoomed, "$zoomed", $$stores);
		let props = prop($$props, "props", 8);
		let smallScreen = prop($$props, "smallScreen", 8);

		let {
			activeItem,
			opts,
			prev,
			next,
			zoomed,
			container
		} = props();

		let maxZoom = activeItem.maxZoom || opts.maxZoom || 10;
		let calculatedDimensions = mutable_state(props().calculateDimensions(activeItem));
		/** value of sizes attribute */
		let sizes = mutable_state(get(calculatedDimensions)[0]);

		/** tracks load state of image */
		let loaded = mutable_state(),
			showLoader = mutable_state();

		/** stores pinch info if multiple touch events active */
		let pinchDetails;
		/** image html element (.bp-img) */
		let bpImg;
		/** track distance for pinch events */
		let prevDiff = 0;

		let pointerDown = mutable_state(),
			hasDragged;

		let dragStartX, dragStartY;
		/** zoomDragTranslate values on start of drag */
		let dragStartTranslateX, dragStartTranslateY;
		/** if true, adds class to .bp-wrap to avoid image cropping */
		let closingWhileZoomed;
		const naturalWidth = +activeItem.width;
		/** store positions for drag inertia */
		const dragPositions = [];
		/** cache pointer events to handle pinch */
		const pointerCache = new Map();
		/** tween to control image size */
		const imageDimensions = tweened(get(calculatedDimensions), defaultTweenOptions(400));
		/** translate transform for pointerDown */
		const zoomDragTranslate = tweened([0, 0], defaultTweenOptions(400));

		// if zoomed while closing, zoom out image and add class
		// to change contain value on .bp-wrap to avoid cropping
		/*$: if ($closing && $zoomed && !opts.intro) {
			const closeTweenOpts = defaultTweenOptions(480)
			zoomDragTranslate.set([0, 0], closeTweenOpts)
			imageDimensions.set(calculatedDimensions, closeTweenOpts)
			closingWhileZoomed = true
		}*/
		/** calculate translate position with bounds */
		const boundTranslateValues = (
			[x, y],
			newDimensions = $imageDimensions()
		) => {
			// image drag translate bounds
			const maxTranslateX = (newDimensions[0] - container.w) / 2;
			const maxTranslateY = (newDimensions[1] - container.h) / 2;

			// x max drag
			if (maxTranslateX < 0) {
				x = 0;
			} else if (x > maxTranslateX) {
				if (smallScreen()) {
					// bound to left side (allow slight over drag)
					x = get(pointerDown) ? maxTranslateX + (x - maxTranslateX) / 10 : maxTranslateX;

					// previous item if dragged past threshold
					if (x > maxTranslateX + 20) {
						// pointerdown = undefined to stop pointermove from running again
						set(pointerDown, prev());
					}
				} else {
					x = maxTranslateX;
				}
			} else if (x < -maxTranslateX) {
				// bound to right side (allow slight over drag)
				if (smallScreen()) {
					x = get(pointerDown) ? -maxTranslateX - (-maxTranslateX - x) / 10 : -maxTranslateX;

					// next item if dragged past threshold
					if (x < -maxTranslateX - 20) {
						// pointerdown = undefined to stop pointermove from running again
						set(pointerDown, next());
					}
				} else {
					x = -maxTranslateX;
				}
			}

			// y max drag
			if (maxTranslateY < 0) {
				y = 0;
			} else if (y > maxTranslateY) {
				y = maxTranslateY;
			} else if (y < -maxTranslateY) {
				y = -maxTranslateY;
			}

			return [x, y];
		};

		/** updates zoom level in or out based on amt value */
		function changeZoom(amt = maxZoom, e) {
			if ($closing()) {
				return;
			}

			const maxWidth = get(calculatedDimensions)[0] * maxZoom;
			let newWidth = $imageDimensions()[0] + $imageDimensions()[0] * amt;
			let newHeight = $imageDimensions()[1] + $imageDimensions()[1] * amt;

			if (amt > 0) {
				if (newWidth > maxWidth) {
					// requesting size large than max zoom
					newWidth = maxWidth;
					newHeight = get(calculatedDimensions)[1] * maxZoom;
				}

				if (newWidth > naturalWidth) {
					// if requesting zoom larger than natural size
					newWidth = naturalWidth;
					newHeight = +activeItem.height;
				}
			} else if (newWidth < get(calculatedDimensions)[0]) {
				// if requesting image smaller than starting size
				imageDimensions.set(get(calculatedDimensions));
				return zoomDragTranslate.set([0, 0]);
			}

			let { x, y, width, height } = bpImg.getBoundingClientRect();
			// distance clicked from center of image
			const offsetX = e ? e.clientX - x - width / 2 : 0;
			const offsetY = e ? e.clientY - y - height / 2 : 0;

			x = -offsetX * (newWidth / width) + offsetX;
			y = -offsetY * (newHeight / height) + offsetY;

			const newDimensions = [newWidth, newHeight];

			// set new dimensions and update sizes property
			imageDimensions.set(newDimensions).then(() => {
				set(sizes, Math.round(Math.max(get(sizes), newWidth)));
			});

			// update translate value
			zoomDragTranslate.set(boundTranslateValues(
				[
					$zoomDragTranslate()[0] + x,
					$zoomDragTranslate()[1] + y
				],
				newDimensions
			));
		}

		// allow zoom to be read / set externally
		Object.defineProperty(activeItem, 'zoom', {
			configurable: true,
			get: () => $zoomed(),
			set: (bool) => changeZoom(bool ? maxZoom : -maxZoom)
		});

		const onWheel = (e) => {
			// return if scrolling past inline gallery w/ wheel
			if (opts.inline && !$zoomed()) {
				return;
			}

			// preventDefault to stop scrolling on zoomed inline image
			e.preventDefault();
			// change zoom on wheel
			changeZoom(e.deltaY / -300, e);
		};

		/** on drag start, store initial position and image translate values */
		const onPointerDown = (e) => {
			// don't run if right click
			if (e.button !== 2) {
				e.preventDefault();
				set(pointerDown, true);
				pointerCache.set(e.pointerId, e);
				dragStartX = e.clientX;
				dragStartY = e.clientY;
				dragStartTranslateX = $zoomDragTranslate()[0];
				dragStartTranslateY = $zoomDragTranslate()[1];
			}
		};

		/** on drag, update image translate val */
		const onPointerMove = (e) => {
			if (pointerCache.size > 1) {
				// if multiple pointer events, pass to handlePinch function
				set(pointerDown, false);
				return opts.noPinch?.(container.el) || handlePinch(e);
			}

			if (!get(pointerDown)) {
				return;
			}

			let x = e.clientX;
			let y = e.clientY;

			// store positions in dragPositions for inertia
			// set hasDragged if > 2 pointer move events
			hasDragged = dragPositions.push({ x, y }) > 2;
			// overall drag diff from start location
			x = x - dragStartX;
			y = y - dragStartY;

			// handle unzoomed left / right / up swipes
			if (!$zoomed()) {
				// close if swipe up
				if (y < -90) {
					set(pointerDown, !opts.noClose && props().close());
				}

				// only handle left / right if not swiping vertically
				if (Math.abs(y) < 30) {
					// previous if swipe left
					if (x > 40) {
						// pointerdown = undefined to stop pointermove from running again
						set(pointerDown, prev());
					}

					// next if swipe right
					if (x < -40) {
						// pointerdown = undefined to stop pointermove from running again
						set(pointerDown, next());
					}
				}
			}

			// image drag when zoomed
			if ($zoomed() && hasDragged && !$closing()) {
				zoomDragTranslate.set(
					boundTranslateValues([
						dragStartTranslateX + x,
						dragStartTranslateY + y
					]),
					{ duration: 0 }
				);
			}
		};

		const handlePinch = (e) => {
			// update event in cache and get values
			const [p1, p2] = pointerCache.set(e.pointerId, e).values();
			// Calculate the distance between the two pointers
			const dx = p1.clientX - p2.clientX;
			const dy = p1.clientY - p2.clientY;
			const curDiff = Math.hypot(dx, dy);

			// cache the original pinch center
			pinchDetails = pinchDetails || {
				clientX: (p1.clientX + p2.clientX) / 2,
				clientY: (p1.clientY + p2.clientY) / 2
			};

			// scale image
			changeZoom(((prevDiff || curDiff) - curDiff) / -35, pinchDetails);
			// Cache the distance for the next move event
			prevDiff = curDiff;
		};

		/** remove event from pointer event cache */
		const removeEventFromCache = (e) => pointerCache.delete(e.pointerId);

		function onPointerUp(e) {
			removeEventFromCache(e);

			if (pinchDetails) {
				// reset prevDiff and clear pointerDown to trigger return below
				set(pointerDown, prevDiff = 0);
				// set pinchDetails to null after last finger lifts
				pinchDetails = pointerCache.size ? pinchDetails : null;
			}

			// make sure pointer events don't carry over to next image
			if (!get(pointerDown)) {
				return;
			}

			set(pointerDown, false);

			// close if overlay is clicked
			if (e.target === this && !opts.noClose) {
				return props().close();
			}

			// add drag inertia / snap back to bounds
			if (hasDragged) {
				const [posOne, posTwo, posThree] = dragPositions.slice(-3);
				const xDiff = posTwo.x - posThree.x;
				const yDiff = posTwo.y - posThree.y;

				if (Math.hypot(xDiff, yDiff) > 5) {
					zoomDragTranslate.set(boundTranslateValues([
						$zoomDragTranslate()[0] - (posOne.x - posThree.x) * 5,
						$zoomDragTranslate()[1] - (posOne.y - posThree.y) * 5
					]));
				}
			} else if (!opts.onImageClick?.(container.el, activeItem)) {
				changeZoom($zoomed() ? -maxZoom : maxZoom, e);
			}

			// reset pointer states
			hasDragged = false;
			// reset dragPositions
			dragPositions.length = 0;
		}

		const onMount = (node) => {
			bpImg = node;

			// handle window resize
			props().setResizeFunc(() => {
				set(calculatedDimensions, props().calculateDimensions(activeItem));

				// adjust image size / zoom on resize, but not on mobile because
				// some browsers (ios safari 15) constantly resize screen on drag
				if (opts.inline || !smallScreen()) {
					imageDimensions.set(get(calculatedDimensions));
					zoomDragTranslate.set([0, 0]);
				}
			});

			// decode initial image before rendering
			props().loadImage(activeItem).then(() => {
				set(loaded, true);
				props().preloadNext();
			});

			// show loading indicator if needed
			setTimeout(
				() => {
					set(showLoader, !get(loaded));
				},
				250
			);
		};

		const addSrc = (node) => {
			addAttributes(node, activeItem.attr);
			node.srcset = activeItem.img;
		};

		legacy_pre_effect(
			() => (
				$imageDimensions(),
				get(calculatedDimensions)
			),
			() => {
				zoomed.set($imageDimensions()[0] - 10 > get(calculatedDimensions)[0]);
			}
		);

		legacy_pre_effect_reset();
		init();

		var div = root$2();

		toggle_class(div, "bp-close", closingWhileZoomed);

		var div_1 = child(div);
		const style_directive = derived_safe_equal(() => getThumbBackground(activeItem));
		var node_1 = child(div_1);

		if_block(node_1, () => get(loaded), ($$anchor) => {
			var img = root_1$1();

			action(img, ($$node) => addSrc($$node));
			effect(() => event("error", img, (error) => opts.onError?.(container, activeItem, error)));

			template_effect(() => {
				set_attribute(img, "sizes", opts.sizes || `${get(sizes)}px`);
				set_attribute(img, "alt", activeItem.alt);
			});
			transition(6, img, () => fly);
			append($$anchor, img);
		});

		var node_2 = sibling(node_1, 2);

		if_block(node_2, () => get(showLoader), ($$anchor) => {
			Loading($$anchor, {
				activeItem,
				get loaded() {
					return get(loaded);
				}
			});
		});
		action(div_1, ($$node) => onMount($$node));

		template_effect(() => {
			set_attribute(div_1, "style", `
			width:${$imageDimensions()[0] ?? ""}px;
			height:${$imageDimensions()[1] ?? ""}px;
		`);

			toggle_class(div_1, "bp-drag", get(pointerDown));
			toggle_class(div_1, "bp-canzoom", maxZoom > 1 && $imageDimensions()[0] < naturalWidth);
			set_style(div_1, "background-image", get(style_directive));
			set_style(div_1, "transform", `translate3d(${$imageDimensions()[0] / -2 + $zoomDragTranslate()[0] ?? ""}px, ${$imageDimensions()[1] / -2 + $zoomDragTranslate()[1] ?? ""}px, 0)`);
		});

		event("wheel", div, onWheel, undefined, true);
		event("pointerdown", div, onPointerDown);
		event("pointermove", div, onPointerMove);
		event("pointerup", div, onPointerUp);
		event("pointercancel", div, removeEventFromCache);
		append($$anchor, div);
		pop();
	}

	var root$1 = template(`<div class="bp-if"><iframe allow="autoplay; fullscreen"></iframe> <!></div>`);

	function Iframe($$anchor, $$props) {
		push($$props, false);

		let props = prop($$props, "props", 8);

		let loaded = mutable_state(),
			dimensions = mutable_state();

		const { activeItem } = props();
		const setDimensions = () => set(dimensions, props().calculateDimensions(activeItem));

		setDimensions();
		props().setResizeFunc(setDimensions);

		const addSrc = (node) => {
			addAttributes(node, activeItem.attr);
			node.src = activeItem.iframe;
		};

		init();

		var div = root$1();
		var iframe = child(div);

		action(iframe, ($$node) => addSrc($$node));
		effect(() => event("load", iframe, () => set(loaded, true)));

		var node_1 = sibling(iframe, 2);

		Loading(node_1, {
			activeItem,
			get loaded() {
				return get(loaded);
			}
		});

		template_effect(() => {
			set_attribute(div, "style", `
		width:${get(dimensions)[0] ?? ""}px;
		height:${get(dimensions)[1] ?? ""}px
	`);

			set_attribute(iframe, "title", activeItem.title);
		});
		append($$anchor, div);
		pop();
	}

	var root = template(`<div class="bp-vid"><!></div>`);

	function Video($$anchor, $$props) {
		push($$props, false);

		let props = prop($$props, "props", 8);

		let loaded = mutable_state(),
			dimensions = mutable_state();

		const { activeItem, opts, container } = props();
		const setDimensions = () => set(dimensions, props().calculateDimensions(activeItem));

		setDimensions();
		props().setResizeFunc(setDimensions);

		/** create audo / video element */
		const onMount = (node) => {
			let mediaElement;

			/** takes supplied object and creates elements in video */
			const appendToVideo = (tag, arr) => {
				if (!Array.isArray(arr)) {
					arr = JSON.parse(arr);
				}

				for (const obj of arr) {
					// create media element if it doesn't exist
					if (!mediaElement) {
						mediaElement = document.createElement(obj.type?.includes('audio') ? 'audio' : 'video');

						addAttributes(mediaElement, {
							controls: true,
							autoplay: true,
							playsinline: true,
							tabindex: '0'
						});

						addAttributes(mediaElement, activeItem.attr);
					}

					// add sources / tracks to media element
					const el = document.createElement(tag);

					addAttributes(el, obj);

					if (tag == 'source') {
						el.onError = (error) => opts.onError?.(container, activeItem, error);
					}

					mediaElement.append(el);
				}
			};

			appendToVideo('source', activeItem.sources);
			appendToVideo('track', activeItem.tracks || []);
			mediaElement.oncanplay = () => set(loaded, true);
			node.append(mediaElement);
		};

		init();

		var div = root();
		const style_directive = derived_safe_equal(() => getThumbBackground(activeItem));
		var node_1 = child(div);

		Loading(node_1, {
			activeItem,
			get loaded() {
				return get(loaded);
			}
		});
		action(div, ($$node) => onMount($$node));

		template_effect(() => {
			set_attribute(div, "style", `
			width:${get(dimensions)[0] ?? ""}px;
			height:${get(dimensions)[1] ?? ""}px;
		`);

			set_style(div, "background-image", get(style_directive));
		});

		append($$anchor, div);
		pop();
	}

	var on_pointerdown = (e, clickedEl) => set(clickedEl, proxy(e.target));

	var on_pointerup = function (e, clickedEl, opts, close) {
		// only close if left click on self and not dragged
		if (e.button !== 2 && e.target === this && get(clickedEl) === this) {
			!get(opts).noClose && close();
		}
	};

	var root_8 = template(`<div class="bp-html"><!></div>`);
	var root_9 = template(`<div class="bp-cap"><!></div>`);
	var root_2 = template(`<div class="bp-inner"><!></div> <!>`, 1);

	var on_click = (_, activeItem) => {
		const url = Object.hasOwn(get(activeItem), 'full') ? get(activeItem)['full'] : get(activeItem)['img'];

		window.open(url, '_blank');
	};

	var on_click_1 = (__1, activeItem, downloadPhoto) => {
		const url = Object.hasOwn(get(activeItem), 'full') ? get(activeItem)['full'] : get(activeItem)['img'];

		downloadPhoto(url, url.replace(/.*\//, ''));
	};

	var root_10 = template(`<div class="bp-count"><!></div> <button class="bp-prev" title="Previous" aria-label="Previous"></button> <button class="bp-next" title="Next" aria-label="Next"></button>`, 1);
	var root_1 = template(`<div class="bp-wrap"><div></div> <!> <div class="bp-controls"><button class="bp-base bp-x" title="Close" aria-label="Close"></button> <button class="bp-base bp-ext" title="Open Fullsize" aria-label="Open Fullsize"></button> <button class="bp-base bp-save" title="Save" aria-label="Save"></button>  <!></div></div>`);

	function Bigger_picture($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $zoomed = () => store_get(zoomed, "$zoomed", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {any} [items] - items currently displayed in gallery
		 * @property {any} [target] - element the gallery is mounted within (passed during initialization)
		 */
		/** @type {Props} */
		let items = prop($$props, "items", 15, undefined),
			target = prop($$props, "target", 7, undefined);

		const html$1 = document.documentElement;
		/** index of current active item */
		let position = state(undefined);
		/** options passed via open method */
		let opts = state(undefined);
		/** bool tracks open state */
		let isOpen = state(undefined);
		/** dom element to restore focus to on close */
		let focusTrigger;
		/** bool true if container width < 769 */
		let smallScreen = state(undefined);
		/** bool value of inline option passed in open method */
		let inline = state(undefined);
		/** when position is set */
		let movement;
		/** stores target on pointerdown (ref for overlay close) */
		let clickedEl = state(undefined);
		/** active item object */
		let activeItem = state(undefined);
		/** returns true if `activeItem` is html */
		const activeItemIsHtml = () => !get(activeItem).img && !get(activeItem).sources && !get(activeItem).iframe;
		/** function set by child component to run when container resized */
		let resizeFunc;
		/** used by child components to set resize function */
		const setResizeFunc = (fn) => resizeFunc = fn;
		/** container element (el) / width (w) / height (h) */
		const container = proxy({});
		// /** true if image is currently zoomed past starting size */
		const zoomed = writable(0);

		run(() => {
			if (items()) {
				// update active item when position changes
				set(activeItem, proxy(items()[get(position)]));

				if (get(isOpen)) {
					// run onUpdate when items updated
					get(opts).onUpdate?.(container.el, get(activeItem));
				}
			}
		});

		const open = (options) => {
			set(opts, proxy(options));
			set(inline, proxy(get(opts).inline));

			// add class to hide scroll if not inline gallery
			if (!get(inline) && html$1.scrollHeight > html$1.clientHeight) {
				html$1.classList.add('bp-lock');
			}

			// update trigger element to restore focus
			focusTrigger = document.activeElement;
			container.w = target().offsetWidth;
			container.h = target() === document.body ? window.innerHeight : target().clientHeight;
			set(smallScreen, container.w < 769);
			set(position, proxy(get(opts).position || 0));
			// set items
			items([]);

			for (let i = 0; i < (get(opts).items.length || 1); (i += 1) - 1) {
				let item = get(opts).items[i] || get(opts).items;

				if ('dataset' in item) {
					items().push({ element: item, i, ...item.dataset });
				} else {
					item.i = i;
					items().push(item);
					// set item to element for position check below
					item = item.element;
				}

				// override gallery position if needed
				if (get(opts).el && get(opts).el === item) {
					set(position, proxy(i));
				}
			}
		};

		const close = () => {
			get(opts).onClose?.(container.el, get(activeItem));
			closing.set(true);
			items(null);
			// restore focus to trigger element
			focusTrigger?.focus({ preventScroll: true });
		};

		const prev = () => setPosition(get(position) - 1);
		const next = () => setPosition(get(position) + 1);

		const setPosition = (index) => {
			movement = index - get(position);
			set(position, proxy(getNextPosition(index)));
		};

		/**
		 * returns next gallery position (looped if neccessary)
		 * @param {number} index
		 */
		const getNextPosition = (index) => (index + items().length) % items().length;

		const onKeydown = (e) => {
			const { key, shiftKey } = e;

			if (key === 'Escape') {
				!get(opts).noClose && close();
			} else if (key === 'ArrowRight') {
				next();
			} else if (key === 'ArrowLeft') {
				prev();
			} else if (key === 'Tab') {
				// trap focus on tab press
				const { activeElement } = document;

				// allow browser to handle tab into video controls only
				if (shiftKey || !activeElement.controls) {
					e.preventDefault();

					const { focusWrap = container.el } = get(opts);
					const tabbable = [...focusWrap.querySelectorAll('*')].filter((node) => node.tabIndex >= 0);
					let index = tabbable.indexOf(activeElement);

					index += tabbable.length + (shiftKey ? -1 : 1);
					tabbable[index % tabbable.length].focus();
				}
			}
		};

		/**
		 * calculate dimensions of height / width resized to fit within container
		 * @param {object} item object with height / width properties
		 * @returns {Array} [width: number, height: number]
		 */
		const calculateDimensions = ({ width = 1920, height = 1080 }) => {
			const { scale = 0.99 } = get(opts);
			const ratio = Math.min(1, container.w / width * scale, container.h / height * scale);

			// round number so we don't use a float as the sizes attribute
			return [
				Math.round(width * ratio),
				Math.round(height * ratio)
			];
		};

		/** preloads images for previous and next items in gallery */
		const preloadNext = () => {
			if (items()) {
				const nextItem = items()[getNextPosition(get(position) + 1)];
				const prevItem = items()[getNextPosition(get(position) - 1)];

				!nextItem.preload && loadImage(nextItem);
				!prevItem.preload && loadImage(prevItem);
			}
		};

		/** loads / decodes image for item */
		const loadImage = (item) => {
			if (item.img) {
				const image = document.createElement('img');

				image.sizes = get(opts).sizes || `${calculateDimensions(item)[0]}px`;
				image.srcset = item.img;
				item.preload = true;
				return image.decode().catch((error) => {});
			}
		};

		/** svelte transition to control opening / changing */
		const mediaTransition = (node, isEntering) => {
			if (!get(isOpen) || !items()) {
				// entrance / exit transition
				set(isOpen, proxy(isEntering));
				return get(opts).intro ? fly(node, { y: isEntering ? 10 : -10 }) : scaleIn(node);
			}

			// forward / backward transition
			return fly(node, {
				x: (movement > 0 ? 20 : -20) * (isEntering ? 1 : -1),
				duration: 250
			});
		};

		/** custom svelte transition for entrance zoom */
		const scaleIn = (node) => {
			let dimensions;

			if (activeItemIsHtml()) {
				const bpItem = node.firstChild.firstChild;

				dimensions = [bpItem.clientWidth, bpItem.clientHeight];
			} else {
				dimensions = calculateDimensions(get(activeItem));
			}

			// rect is bounding rect of trigger element
			const rect = (get(activeItem).element || focusTrigger).getBoundingClientRect();
			const leftOffset = rect.left - (container.w - rect.width) / 2;
			const centerTop = rect.top - (container.h - rect.height) / 2;
			const scaleWidth = rect.width / dimensions[0];
			const scaleHeight = rect.height / dimensions[1];

			return {
				duration: 480,
				easing: cubicOut,
				css: (t, u) => {
					return `transform:translate3d(${leftOffset * u}px, ${centerTop * u}px, 0) scale3d(${scaleWidth + t * (1 - scaleWidth)}, ${scaleHeight + t * (1 - scaleHeight)}, 1)`;
				}
			};
		};

		/** provides object w/ needed funcs / data to child components  */
		const getChildProps = () => ({
			activeItem: get(activeItem),
			calculateDimensions,
			loadImage,
			preloadNext,
			opts: get(opts),
			prev,
			next,
			close,
			setResizeFunc,
			zoomed,
			container
		});

		/** code to run on mount / destroy */
		const containerActions = (node) => {
			container.el = node;

			let roActive;

			get(opts).onOpen?.(container.el, get(activeItem));

			// don't use keyboard events for inline galleries
			if (!get(inline)) {
				window.addEventListener('keydown', onKeydown);
			}

			// set up resize observer
			const ro = new ResizeObserver((entries) => {
				// use roActive to avoid running on initial open
				if (roActive) {
					container.w = entries[0].contentRect.width;
					container.h = entries[0].contentRect.height;
					set(smallScreen, container.w < 769);

					// run child component resize function
					if (!activeItemIsHtml()) {
						resizeFunc?.();
					}

					// run user defined onResize function
					get(opts).onResize?.(container.el, get(activeItem));
				}

				roActive = true;
			});

			ro.observe(node);

			return {
				destroy() {
					ro.disconnect();
					window.removeEventListener('keydown', onKeydown);
					closing.set(false);
					// remove class hiding scroll
					html$1.classList.remove('bp-lock');
					get(opts).onClosed?.();
				}
			};
		};

		const forceDownload = (blobUrl, filename) => {
			let a = document.createElement('a');

			a.download = filename;
			a.href = blobUrl;
			document.body.appendChild(a);
			a.click();
			a.remove();
		};

		const downloadPhoto = (url, filename) => {
			if (!filename) filename = url.split('\\').pop().split('/').pop();

			fetch(url, {
				headers: new Headers({ Origin: location.origin }),
				mode: 'cors'
			}).then((response) => response.blob()).then((blob) => {
				let blobUrl = window.URL.createObjectURL(blob);

				forceDownload(blobUrl, filename);
			}).catch((e) => console.error(e));
		};

		var fragment = comment();
		var node_1 = first_child(fragment);

		if_block(node_1, items, ($$anchor) => {
			var div = root_1();
			var div_1 = child(div);
			var node_2 = sibling(div_1, 2);

			key_block(node_2, () => get(activeItem).i, ($$anchor) => {
				var fragment_1 = root_2();
				var div_2 = first_child(fragment_1);

				div_2.__pointerdown = [on_pointerdown, clickedEl];
				div_2.__pointerup = [on_pointerup, clickedEl, opts, close];

				var node_3 = child(div_2);

				if_block(
					node_3,
					() => get(activeItem).img,
					($$anchor) => {
						var props = derived(getChildProps);

						Image($$anchor, {
							get props() {
								return get(props);
							},
							get smallScreen() {
								return get(smallScreen);
							}
						});
					},
					($$anchor) => {
						var fragment_3 = comment();
						var node_4 = first_child(fragment_3);

						if_block(
							node_4,
							() => get(activeItem).sources,
							($$anchor) => {
								var props_1 = derived(getChildProps);

								Video($$anchor, {
									get props() {
										return get(props_1);
									}
								});
							},
							($$anchor) => {
								var fragment_5 = comment();
								var node_5 = first_child(fragment_5);

								if_block(
									node_5,
									() => get(activeItem).iframe,
									($$anchor) => {
										var props_2 = derived(getChildProps);

										Iframe($$anchor, {
											get props() {
												return get(props_2);
											}
										});
									},
									($$anchor) => {
										var div_3 = root_8();
										var node_6 = child(div_3);

										html(node_6, () => get(activeItem).html ?? get(activeItem).element.outerHTML);
										append($$anchor, div_3);
									},
									true
								);

								append($$anchor, fragment_5);
							},
							true
						);

						append($$anchor, fragment_3);
					}
				);

				var node_7 = sibling(div_2, 2);

				if_block(node_7, () => get(activeItem).caption, ($$anchor) => {
					var div_4 = root_9();
					var node_8 = child(div_4);

					html(node_8, () => get(activeItem).caption);
					transition(6, div_4, () => fly, () => ({ duration: 200 }));
					append($$anchor, div_4);
				});

				transition(5, div_2, () => mediaTransition, () => true);
				transition(6, div_2, () => mediaTransition, () => false);
				append($$anchor, fragment_1);
			});

			var div_5 = sibling(node_2, 2);
			var button = child(div_5);

			button.__click = close;

			var button_1 = sibling(button, 2);

			button_1.__click = [on_click, activeItem];

			var button_2 = sibling(button_1, 2);

			button_2.__click = [on_click_1, activeItem, downloadPhoto];

			var node_9 = sibling(button_2, 2);

			if_block(node_9, () => items().length > 1, ($$anchor) => {
				var fragment_7 = root_10();
				var div_6 = first_child(fragment_7);
				var node_10 = child(div_6);

				html(node_10, () => `${get(position) + 1} / ${items().length}`);

				var button_3 = sibling(div_6, 2);

				button_3.__click = prev;

				var button_4 = sibling(button_3, 2);

				button_4.__click = next;
				append($$anchor, fragment_7);
			});
			action(div, ($$node) => containerActions($$node));

			template_effect(() => {
				toggle_class(div, "bp-zoomed", $zoomed());
				toggle_class(div, "bp-inline", get(inline));
				toggle_class(div, "bp-small", get(smallScreen));
				toggle_class(div, "bp-noclose", get(opts).noClose);
			});

			transition(2, div_1, () => fly, () => ({ duration: 480 }));
			transition(2, div_5, () => fly);
			append($$anchor, div);
		});

		append($$anchor, fragment);

		return pop({
			open,
			close,
			prev,
			next,
			setPosition,
			get items() {
				return items();
			},
			set items($$value) {
				items($$value);
			},
			get target() {
				return target();
			},
			set target($$value) {
				target($$value);
			}
		});
	}

	delegate(["pointerdown", "pointerup", "click"]);

	/**
	 * Initializes BiggerPicture
	 * @param {{target: HTMLElement | null}} options
	 * @returns BiggerPicture instance
	 */
	function biggerPicture (options) {
		return mount(Bigger_picture, {
	    		...options,
	    		props: options,
	    	})
	}

	return biggerPicture;

})();
